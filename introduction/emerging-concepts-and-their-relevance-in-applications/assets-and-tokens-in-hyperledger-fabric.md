# Assets and Tokens in Hyperledger Fabric

Hyperledger Fabric was started in 2015 as an open-source project under the aegis of the Linux Foundation to design a blockchain system suitable for supporting interoperability between companies belonging to a consortium organization.

Therefore, its design goals were from the beginning different from those of the blockchain platforms prevailing at the time, offering some key differentiation capabilities in the management of both network nodes and assets. This system adopts a permissioned network model in which nodes with different functions cooperate to commit transactions on the blockchain. The resulting _execute-order-validate_ workflow, illustrated in **Figure 5**, allows overcoming the following major drawbacks of the order-execute paradigm commonly adopted in blockchain systems \[**48**]:

![](<../../.gitbook/assets/image (2).png>)

**Figure 5.** The transaction processing in Fabric entails three types of nodes, and as many steps as follows: (**1**) peers acting as endorsers check for the correctness of a transaction proposal by a client through the verification of its fields and the execution of the operation(s) provided in its payload; (**2**) orderers assemble all the endorsed transactions provided by clients in ordered blocks, where each block contains a reference to the previous block, and; (**3**) peers check the ordered blocks for valid transactions and store the resulting blocks in their local copy of the blockchain.

1. the trust model for transaction validation is determined at the consensus layer rather than at the application layer, thus forcing transactions to follow a validation workflow that can diverge from the actual application requirements;
2. consensus is hard-coded within the platform, resulting in monolithic applications that are difficult to upgrade and adapt to different network environments and threat scenarios;
3. the fact that all peers should execute all transactions degrades performance, increases consumption, and makes it more challenging to enforce privacy when necessary;
4. smart contracts must be written in a fixed, non-standard, or domain-specific language to avoid the occurrence of non-deterministic or non-terminating executions.

The first of the above issues can find a resolution through the _execute phase_: depending on the trust model at the application layer, an _endorsement policy_ in the smart contract specifies which are the nodes, equipped with a local copy of the blockchain and running the smart contract, that have to check for the correctness of a transaction proposal issued by a client. These nodes, also known as _endorsers_, verify the correct encoding of the transaction proposal and its proper execution, returning the client a proposal response.

The client then collects endorsements until they satisfy the endorsement policy, proceeds to create the transaction, and passes it to the _ordering service_ to give rise to the _order phase_. In this phase, the ordering service establishes a total order on all submitted transactions and outputs transaction blocks suitable to be stored in the blockchain, using a consensus protocol to tolerate faulty or byzantine orderers. Since orderers assemble transactions without verifying them, the consensus protocol can be unplugged from the application layer, thus overcoming the second issue.

The ordering service then sends transaction blocks to the network for the _validate phase_, in which the nodes record the blocks in their local copy of the blockchain after tagging their transactions as valid or invalid. This second validity check compares the endorsement responses in the transactions with the current status of the ledger so that transactions are executed only by their endorsers, and the third issue is solved too. Moreover, the double-check performed through the _execute_ and _validate_ phases prevents the occurrence of non-deterministic or non-terminating executions. So, we can write smart contracts using a general-purpose language, such as Go, Java, or Javascript.

By exploiting the above design, Fabric can manage a complex semantic for assets and transactions directly at the ledger layer with its native API, without resorting to additional APIs, such as those defined for Ethereumâ€™s tokens. Accordingly, an asset in Fabric is represented by a generic but finite collection of key-value pairs, with state changes recorded as transactions on the ledger. Specifying suitable collections of key-value pairs makes it possible to consider virtually any kind of asset, from the tangible to the intangible. However, the management of assets does not inherently encompass their monetary value through the system since a cryptocurrency does not back Fabric; in other words, Fabric requires explicit programming to turn its assets into tokens. A research team at IBM has recently designed and implemented the two components Fabric Smart Client and Fabric Token SDK, which should facilitate token exchanges in enterprise contexts \[**42**]. The goal was to design a modular token management system adaptable to various privacy and security regulations. This system adopts the UXTO model pioneered by Bitcoin with some tweaks to support issuance, redemption, transfer, and atomic swap of assets.
