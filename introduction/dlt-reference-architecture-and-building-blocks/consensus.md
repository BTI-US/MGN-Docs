# Consensus

Consensus in distributed computing systems refers to the process of achieving agreement about data that are managed and stored through a set of network participants so that such nodes share the same state as the correct one for the system at a given point in time. In the context of blockchain systems, the consensus has to guarantee that all the ledger replicas deployed through the system are the same (blockchain _consistency_), except possibly for a small number of terminal blocks still awaiting a final decision (_eventual consistency_). These consistent ledger replicas provide a certain degree of tolerance to unresponsive nodes and those that arbitrarily deviate from the application logic, thus representing a more resilient and secure alternative to the trusted third-party approach. Trust indeed gets split over multiple nodes, which must collude or get hacked simultaneously so that the system as a whole deviates from its correct functioning. In order for things to work, however, procedures that can filter out those nodes trying to undermine a correct agreement process are necessary, and this is precisely the goal of every consensus protocol.

A node can become unresponsive because of a network failure resulting in the disconnection of the node from the network, or as a consequence of a _crash fault_, where the node abruptly stops working without quickly resuming because of a power outage, a DoS attack, or an error in its software or hardware. Regardless of the nature of the fault that halted a node, a consensus protocol must terminate correctly as long as the percentage of failures does not exceed a certain threshold. As suggested by the intuition, a protocol for which consensus follows from a majority quorum, as it is common practice in the P2P model, can withstand a certain number of unresponsive nodes less than half of the total.

Much more challenging to manage than nodes subject to halt faults are those that try to hinder a correct consensus process thanks to subtle and illegal actions of various types, ranging from the tampering of existing transactions or the creation of false ones (as in double spending) to the modification of the protocol itself, through message manipulation and reordering. These actions may include not responding to messages sent by the other peers, thus encompassing halt failures.

In general, some consensus protocols tolerate unresponsive nodes but not malicious ones (e.g., Zab \[**28**], Raft \[**29**]), whereas a protocol designed to withstand malicious nodes will also tolerate unresponsive nodes to a greater extent. Depending on the blockchain consensus protocol, we can measure fault tolerance as a percentage of the number of malicious nodes or their used resources from the total number of nodes or resources involved in the consensus process. This measure reflects the first fundamental discrimination for blockchain consensus protocols, which we can divide into the two broad classes of _membership-based_ procedures and _fitness-based_ procedures, in addition to a further class of hybrid methods obtained by combining the two previous approaches.

In membership-based protocols, a predetermined and reduced set of nodes with explicit identities and roles, often coordinated by a leader (a.k.a. primary) node that acts as an interface with clients, forms a committee, reaching agreement through multiple rounds of message exchange to achieve a consensus. In this respect, the committee represents a server consortium that has to order transaction proposals as they arrive by clients, arranging them in a valid chain of blocks despite some servers failing. Accordingly, the correctness of consensus for these protocols can be formulated by recasting two concepts introduced in \[**30**]: (i) every server correctly executes the same sequence of (transaction) requests (_safety_), and; (ii) all requests are served (_liveness_). In this context, we can call malicious nodes and faults “Byzantine”, whereas consensus protocols that exhibit some degree of tolerance to them are called _Byzantine-fault tolerant_ (BFT) protocols. This terminology has come into use after \[**31**], in which the authors introduce the consensus problem making the analogy where a group of generals of the Byzantine army must agree on a common battle plan, communicating only through messengers and despite some traitors hiding among them generate conflicting messages to hamper agreement.

It is shown in \[**21**] that BFT protocols cannot tolerate a critical number of Byzantine nodes greater than or equal to one-third of the total number of nodes involved in the server consortium. Another prominent limitation of these protocols, and more generally of membership-based protocols, is that they require explicit message passing among the _N_ nodes composing the consortium, typically exhibiting a O(N2) message complexity, which turns out to be a considerable networking overhead already for consortia of a few tens of nodes. These protocols are, therefore, suitable only for permissioned blockchains and can offer a limited degree of decentralization. As for the bright side, membership-based protocols offer _consensus finality_, in that each consensus decision, as returned by the protocol, is conclusive and cannot be subject to changes or cancellation at later times. Thus, a block of transactions chosen to get transcribed on the blockchain can no longer change or get canceled later, allowing block intervals and transaction throughput comparable to those of centralized systems. Some protocols (e.g., PBFT \[**32**] and its derivatives) that follow the _state machine replication_ (SMR) scheme formalized in \[**33**] fall into the BFT category, with other more recent protocols having different message workflows (e.g., HoneyBadgerBFT \[**33**] and the related protocol suite BEAT \[**34**]).

Fitness-based consensus protocols have a design suitable for large and open sets of participating nodes whose exact size and members are not known a priori. The crucial element underlying this broad category of protocols is the use of a resource, internal or external to the system, which serves to quantify the fitness of the nodes (i.e., their influence or power) in the consensus process. Such a resource is necessary for the context of permissionless networks, where an arbitrary (and anonymous) node has the opportunity to participate in the management of the blockchain. It indeed serves to constrain the node power to the quantity of the resource they wish or can invest in the consensus process, thus counteracting Sybil attacks and their derivatives.

Another central element that virtually distinguishes all protocols suitable for permissionless systems is the ability of the node to add a new block to prove publicly (i.e., to the rest of the network) that it is indeed enabled to do so based on its fitness. Accordingly, authors in the literature denote these protocols as _proof-based_ consensus protocols.

Since these protocols operate on P2P networks, allowing the decentralized management of trust and services in a much broader and flexible way than in client-server models, they have been singularly studied in recent years precisely in conjunction with and about the development of DLT, of which they represent a core aspect. Indeed, since the activation of the Bitcoin network, research contributions have multiplied, with dozens of new protocol proposals that, in many cases, have been implemented in functioning systems. Due to their importance for DLT and their primary role in the enforcement of decentralization and such technologies, we will allude below to the main types of these protocols; the interested reader should refer to specific literature contributions for a more comprehensive and in-depth treatment of this topic.

**Table 3.** A list of some major network-oriented (NET) and committee-oriented (COM) blockchain consensus protocols.

![](file:///C:/Users/Phill/AppData/Local/Temp/ksohtml/wps2F11.tmp.jpg)&#x20;

### 1. Network-Oriented Consensus Protocols

These protocols do not rely on explicit message exchanges among a committee to establish consensus, but rather on an algorithm that allows nodes by themselves to determine if they may add the new current block of transactions, giving corroborated evidence of this to the other nodes thanks to a _proof_ that can be easily and publicly verified. Typically, the algorithm involves solving a computational problem by the node, which can publish the solution found as proof that it is fit to insert the new block. In this regard, the solution to the problem must depend on the current transaction block, although not predictable, and it must not get more manageable knowing additional data, such as the blocks previously recorded on the blockchain. For these reasons, the algorithm makes use of a cryptographic primitive, which returns pseudo-random outputs (precisely, a cryptographic hash function). The choice of the computational problem to solve is critical: a too complex problem affects the liveness of the system, whereas a problem that is too easy to solve weakens its consistency. In fact, in the first case, it could be challenging to find a solver in a reasonable time, while in the second, there could be many solvers and many potentially valid blocks to add to the ledger. Designers usually identify an adequate trade-off thanks to using a system resource for which the node must invest a specific effort and whose availability increases the probability of solving the problem in a relatively short period. This way, the amount of the resource mentioned above represents the _fitness_ a node has in solving the problem. At the same time, its solution is a sort of ticket granting access to the final tender, which establishes who will be able to add the current block to the blockchain. Indeed, there can be multiple problem solvers that correspond to as many current blocks, all potentially valid, but which must get selected according to a system rule to obtain a single shared list of consecutive blocks. It follows that network-oriented consensus protocols consist of the three following phases, according to a timeline composed of time frames in each of which potentially all the nodes in the network compete for the addition of a new block in the blockchain:

· _Proposal_: where a node assembles a block of transactions and attaches proof to it demonstrating its investment of the fitness resource in such a task;

· _Validation_: in which nodes check the validity of the blocks proposed in the previous phase, alongside with their alleged proofs;

· _Finalization_: in which the network, following a rule usually based on the majority of participants, selects a unique block among those that passed the validation phase.

Because of their implicit agreement model, network-oriented consensus protocols scale much better than membership-based protocols to the number of nodes involved: their message complexity can be indeed limited to O(1) for each node by exploiting the communication models described in **Section 3.4**. However, this comes at the price of both higher costs and worse performance. Consensus does not conclude with the validation phase, but it requires an extra finalization process, which by its nature is not deterministic and could take time since it depends upon a large number of loosely coupled nodes. Therefore, it impacts negatively on the transaction throughput. Cost, on the other hand, does not depend so much on sending and receiving messages and on the local processing required about this, as in the membership-based protocols, but rather on the fact that it is necessary to counteract Sybil attacks and those related to them (e.g., double spending) thanks to considerable consumption of the fitness resource by the nodes. After more than a decade of research in the field, the actual cost of a proof-based protocol can be far lower than for the proof-of-work implemented in Bitcoin since it strongly depends on the choice and management of the fitness function. However, these costs are decidedly higher for network-oriented consensus protocols than those of the membership-based protocols, if only because many more nodes are involved in the consensus process.

Falling in this category: protocols at the core of many well-established cryptocurrencies (e.g., Bitcoin \[**35**], Ethereum \[**36**], Peercoin \[**37**], Nxt \[**38**]), altcoin proposals never came to light as Permacoin \[**39**], as well as systems not intrinsically tied to a cryptocurrency (e.g., Hyperledger Sawtooth \[**40**]). The fitness resource used by the nodes in these systems is typically hashing power or stake value; however, other choices are also possible, as the amount of stored data in Permacoin or the disposal of a trusted execution environment (specifically, Intel SGX \[**41**]) in Sawtooth.

By allowing a limited set of users to take control of the network, selfish mining and other illegal mining strategies ultimately threaten the decentralization aimed by permissionless blockchains. However, a centralization risk for proof-based consensus systems stems from the “wealthy get wealthier” paradigm: nodes having more fitness (hashing power or stake value) than others can lawfully exploit this advantage to accumulate more and more wealth over time, potentially reducing the system to an oligopoly. This attitude is particularly true for PoS systems, where miners can reinvest their profits into staking over and over again.

Next, \[**42**] tries to mitigate some of the above issues thanks to the following rules: (i) designers determined token supply at the origin and the reward for inserting a new block only comes from transaction fees; (ii) users cannot split stakes over multiple simultaneous mining activities, and; (iii) the stake value is appreciated due to the mining activity during a block cycle, but it is reset to the base value once the cycle ends.

These and other similar rules can encourage users to participate and honestly validate transactions; however, they do not overcome the two primary limits of current network-oriented systems. The first limit concerns performance: the fact that the consensus process potentially involves all the network nodes entails a considerable time for the finalization phase. Even adopting particular strategies for determining the main chain, such as GHOST or the variant currently implemented in Ethereum (see **Section 3.2**), the times for confirming a transaction are orders of magnitude greater than for membership-based systems. The second limit concerns security: the arguments supporting the security of these systems are indeed only of a heuristic nature due to the lack of formal reference models and precise definitions. Therefore, these systems could prove to be vulnerable by design at a later time, with potential irremediable damage to their investors, which the use of a cryptocurrency can exacerbate. The case of selfish mining for Bitcoin is exemplary in this respect: this network has not yet been the subject of such an attack, presumably solely because its users believe that its longevity and reputation can safeguard their earnings.

Therefore, two somewhat complementary principles guided research efforts in recent years: (i) drawing inspiration from skills and methodologies acquired in the thirty-year development of membership-based consensus systems, and; (ii) exploiting formal mathematical proofs based on adequate cryptographic primitives to obtain provably secure consensus protocols.

These led to the protocols briefly discussed in the following section.
