# Application

This layer is responsible for two primary tasks: user management and specification of the services that can be delivered by the system, possibly according to users’ roles and attributes.

### 1. User Management

User management is very different depending on whether it is related to permissioned or permissionless systems: in permissionless systems, the difference between nodes composing the system network and client nodes lies in a grey area, whereas in permissioned systems, there is a clear distinction between clients and servers, and the latter can have different roles. In general, nodes that submit requests to register transactions on the ledger or access the ledger in reading mode are considered users or clients. In contrast, system nodes actively manage the network, representing the set of distributed computational resources that replicate the ledger and offer its related services to the clients. In permissionless systems, clients can opt to take an active role, and vice versa, so that a given node can act as a client, system node, or both, and this happens at the node owner’s discretion and not in a predetermined manner, as encoded in some system account policy. Accordingly, there is no distinction between clients and blockchain nodes: they are considered blockchain nodes that can transact with the other nodes and participate in building the blockchain. In order to perform the above tasks, a blockchain node needs a unique identifying address, and this address must be such that another node can verify that the emitted and received data are genuinely coming from or destined to that address. A blockchain address, along with its balance in digital coins or some other kind of asset, is named an _account_ or _wallet_: it represents how users are identified and managed in the system. Accounts can be implemented thanks to a digital signature scheme \[**18**] by generating pairs of private-public keys: if a source uses a private key to sign a transaction, the corresponding public key is the one identifying the source address; analogously, if a transaction has a public key as the destination address, only the owner of the corresponding private key will be able to redeem it. In a permissionless system, private-public key pairs for a given node are generated independently by the node owner, without any support by a Certification Authority (CA) \[**22**]. Therefore no connection is attested between the identity of the node owner and such keys. Some systems, such as Bitcoin, add further protection to users’ anonymity thanks to a transaction model that resembles cash transfers, which will be touched upon shortly. Things are very different in the case of permissioned systems, for which multiple CAs can create a Public Key Infrastructure (PKI) \[**23**] architecture capable of reflecting the different organizations that belong to the network and the roles of their units, both in terms of departments, blockchain nodes, and personnel. An example in this regard is Hyperledger Fabric, where a component called Membership Service Provider (MSP) \[**12**] is designed to abstract away all cryptographic mechanisms and protocols behind issuing certificates, validating certificates, and user authentication.

We point out that the permissionless and permissioned approaches represent two radically different ways of implementing decentralization in digital services, each with pros and cons. The permissionless technology allows the creation of platforms to provide IT services as an alternative to cloud platforms. Similar to cloud platforms, permissionless DL systems are deployed and used globally. New generation systems, such as Ethereum, can provide computing infrastructures and software services in analogy with the _IaaS_ and _SaaS_ models \[**24**]. However, unlike cloud platforms, they are collaborative platforms that aim to achieve massive decentralization thanks to the involvement of users, openly and anonymously. This approach avoids concerns and security issues related to unreliable or unqualified cloud service providers. However, it comes at the price of minor performance and greater complexity in system architecture and management, which could give rise to security issues. As pointed out in **Section 2.2**, permissionless systems are not trustless: they simply shift trust from a central authority to a suite of protocols and the community in charge of implementing and managing them. Instead, we can consider permissioned technology an evolution of cloud technology: it allows to decentralize trust in _multi-tenant_ SaaS \[**25**] environments hosted on clouds. A new category of cloud computing services, known as _blockchain-as-a service_ (BaaS), has emerged in the last few years. Many cloud service providers offer BaaS turnkey solutions running on their cloud infrastructures (e.g., AWS, IBM, Microsoft, and Oracle).

### 2. Service Specification

At the core of service specification for DL systems, there is the notion of _transaction_. It indeed represents the atomic operation to be tracked in the ledger and the only way to trigger a change in the system; in some platforms (e.g., Hyperledger Fabric), transactions represent the only way to interact with the ledger since they are required not only to write data on it but also to read data from it. In a system backed by a cryptocurrency, transactions are first and foremost static data records tracking digital coin transfers between senders and receivers. In Bitcoin, for example, a transaction specifies a list of inputs and a list of outputs where each input encodes a value in bitcoins (MGN) representing an unspent transaction output (UTXO) for the sender, and each output encodes a value in MGN along with the receiver address, so that the sum of the input values is not less than that of the output values. In order to get a valid transaction, the sender has to sign each transaction input properly to redeem its value and be able to use it in an output, possibly summed to other input values. If output values result in a smaller sum than the inputs, the system adds a UTXO for the sender to the transaction to equalize the difference. For example, Alice could redeem 0.05 MGN and 1.181 MGN from two of her UTXOs to transfer 0.67 MGN and 0.63 MGN to Bob and Eve, respectively, getting back a new UTXO of 0.381 MGN by the system.

All decentralized applications rely on state, transition rules, and history, but the implementation of these notions can significantly vary depending on the particular system. The _state_ is data currently stored in the ledger that, along with the _transition rules_, determines the following (finite) set of possible valid states. When a transaction is a request for a change in the ledger’s state, it will be considered valid or invalid by the system according to its current state and its transition rules. Finally, the _history_ is the set of all previous transactions and the order in which they occurred in the ledger.

In the Bitcoin system, the state is the set of all UTXOs with their addresses at a specific time. For each transaction, its encoded program instructions check if the transaction inputs correspond to previous UTXOs for the sender, which she cryptographically signed for redemption. If the answer is yes, the transaction is registered into the ledger, indicating that its output values are UTXOs for the many related output addresses.

The UTXO model allows for the simple and effective management of transfers of fungible assets, such as money; however, it does not explicitly associate ownership of assets with users, as required by many use cases other than cryptocurrencies. Therefore, more recent systems do not adopt the UTXO model; but instead, they have an explicit notion of _account balance_ used to keep track of all the cryptocurrency or digital tokens owned by a user. Some systems (e.g., Hyperledger Fabric) further extend this functionality by allowing users to own generic digital assets not necessarily linked to a cryptocurrency.
